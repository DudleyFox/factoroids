<html>
<!-- 
        Copyright ï¿½ 2022 Dudley Fox
    -->

<head>
    <meta http-equiv="X-UA-Compatible" content="chrome=1, IE=edge">
    <!-- from https://stackoverflow.com/questions/4288253/html5-canvas-100-width-height-of-viewport -->
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: black;
        }
    </style>
</head>

<body>
    <canvas id="AstCan"></canvas>
    <script src="Primes.js"></script>
    <script src="KeyHandler.js"></script>
    <script src="AAAHelpers.js"></script>
    <script>
        let bullets = [];
        let facts = [];
        const steps = [5, 6, 8, 9, 10, 12, 15, 18, 20, 24, 30, 36, 40, 45];
        let fb = [
            {
                name: 'Default',
            },
            {
                name: 'Splinter'
            }
        ];
        let fbIndex = 0;
        let fbCooldown = 0;

        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
        }

        function generateColor(p) {
            const adjust = Math.abs(Math.cos(p))
            const blue = Math.floor(88 * adjust);
            return `#7777${(0x77 + blue).toString(16)}`
        }

        class BaseSprite {
            constructor(origin, upperBounds) {
                this.upperBounds = upperBounds;
                this.xPos = origin.x;
                this.yPos = origin.y;
            }
            setUpperBounds(ub) {
                this.upperBounds = ub;
            }
            draw(context) {
                throw new Error('Did you forget to implement this?');
            }
            update(delta) {
                throw new Error('Did you forget to implement this?');
            }
        }

        class BaseSpecial {
            constructor() {
                this.cooldown = 0;
            }
            tick() {
                if (this.cooldown > 0) {
                    this.cooldown -= 1;
                }
            }
            update(ship, factoroids, delta) {
                throw new Error('Did you forget to implement this?');
            }
        }

        class FlipSpecial extends BaseSpecial {
            constructor() {
                super();
            }

            update(ship, factoroids, delta) {
                if (this.cooldown === 0) {
                    ship.rotation += 180;
                    this.cooldown = 15;
                }

            }
        }

        class HyperSpecial extends BaseSpecial {
            constructor() {
                super();
            }

            update(ship, factoroids, delta) {
                if (this.cooldown === 0) {
                    const newX = Math.random() * ship.upperBounds.x;
                    const newY = Math.random() * ship.upperBounds.y;
                    const newR = Math.random() * 360;
                    ship.xPos = newX;
                    ship.yPos = newY;
                    ship.rotation = newR;
                    ship.xVelocity = 0;
                    ship.yVelocity = 0;
                    // ship.collisionShieldCountdown = 4;
                    this.cooldown = 15;
                }
            }
        }

        class Factoroid extends BaseSprite {
            constructor(product, origin, upperBounds, vector, magnitude = 10) {
                super(origin, upperBounds);
                this.product = product;
                this.factors = new Array();
                this.points = new Array();
                this.innerPoints = new Array();
                this.radii = new Array();
                this.maxRadius = 0;
                this.minRadius = 100000;
                this.rotationSpeed = this.adjustDirection(Math.random());
                this.rotation = 0;
                this.vector = vector || Math.random() * 360;
                this.magnitude = magnitude;
                this.xVelocity = Math.cos(degreesToRadians(this.vector)) * magnitude;
                this.yVelocity = Math.sin(degreesToRadians(this.vector)) * magnitude;
                this.color = generateColor(this.product);
                this.dead = false;
                this.centers;
                this.maxSize = product * 7;
                this.spawn = [];
                this.hasSpawn = false;

                this.generateFactors();
                this.generatePoints();
                this.generateCenters();
            }

            adjustDirection(aValue) {
                return aValue * coinToss();
            }

            update(delta) {
                this.rotation = (this.rotation + this.rotationSpeed) % 360;
                this.points = new Array();
                for (i = 0; i < 360; i += 5) {
                    var theta = degreesToRadians(i + this.rotation);
                    var x = (this.radii[i / 5] * Math.cos(theta));
                    var y = -(this.radii[i / 5] * Math.sin(theta));
                    this.points.push(new Point(x, y));
                }
                this.xPos += this.xVelocity * delta;
                this.yPos += this.yVelocity * delta;


                if (this.xPos < 0) {
                    this.xPos = this.upperBounds.x + this.xPos;
                }
                else if (this.xPos > this.upperBounds.x) {
                    this.xPos = this.xPos - this.upperBounds.x
                }
                if (this.yPos < 0) {
                    this.yPos = this.upperBounds.y + this.yPos;
                }
                else if (this.yPos > this.upperBounds.y) {
                    this.yPos = this.yPos - this.upperBounds.y
                }

                this.generateCenters();
            }

            generateFactors() {
                // GetFactors
                this.factors = [];
                var t = this.product
                var index = 0
                var sqt = Math.sqrt(t)
                while (t != 1) {
                    var factor = primes[index]
                    if ((t % factor) === 0) {
                        this.factors.push(factor);
                        t = t / factor;
                        sqt = Math.sqrt(t)
                    }
                    else {
                        index += 1;
                        factor = primes[index];
                        if (factor > sqt) {
                            this.factors.push(t);
                            return;
                        }
                    }
                }
            }

            sumTheFactors(theta) {
                let sum = 0;

                for (let i = 0; i < this.factors.length; i++) {
                    const f = this.factors[i];
                    sum += Math.cos(f * theta);
                }


                if (sum < 0) {
                    sum = -sum;
                }

                return sum;
            }

            generatePoints() {
                this.points = [];
                this.innerPoints = [];
                this.radii = [];
                var innerDelta = Math.max(this.product, 4);
                var i;
                for (i = 0; i < 360; i += 5) {
                    var theta = degreesToRadians(Number(i));
                    var sum = this.sumTheFactors(theta);
                    var radius = (Math.log(this.product) * (5 + sum)) + 7;
                    var x = (radius * Math.cos(theta));
                    var y = -(radius * Math.sin(theta));
                    var innerX = ((radius - innerDelta) * Math.cos(theta));
                    var innerY = -((radius - innerDelta) * Math.sin(theta));
                    this.points.push(new Point(x, y));
                    this.innerPoints.push(new Point(innerX, innerY));
                    this.radii.push(radius);
                    this.maxRadius = Math.max(this.maxRadius, radius);
                    this.minRadius = Math.min(this.minRadius, radius);
                }
            }

            stabilize() {
                let num = this.product;
                const vector = Math.random() * 360;
                const stableFactoroids = [];
                while (num > 2) {
                    let s = Math.floor(Math.random() * num);
                    if (s >= 2) {
                        num -= s;
                        if (num < 2) {
                            s += num; // just take the rest
                            num = 0;
                        }
                        const v = coinToss() === 1 ? vector : vector + 180;
                        const f = new Factoroid(s, new Point(this.xPos, this.yPos), this.upperBounds, v, Math.random() * 50);
                        stableFactoroids.push(f);
                    }

                }
                return stableFactoroids;
            }

            inCollision(item, fx, fy) {
                const dist = distanceBetweenTwoPoints(item.xPos, item.yPos, fx, fy);
                if (dist > (this.maxRadius + item.radius)) {
                    return false;
                }
                if (dist < (this.minRadius + item.radius)) {
                    return true;
                }

                const rr = item.getRotatedRadius();

                for (let i = 0; i < this.points.length; ++i) {
                    if (
                        linesIntersect(rr.x1, rr.y1, rr.x2, rr.y2, this.xPos, this.yPos, this.points[i].x + this.xPos, this.points[i].y + this.yPos)
                        || linesIntersect(item.xPos, item.yPos, item.xPos - item.xVel, item.yPos - item.yVel, this.xPos, this.yPos, this.points[i].x + this.xPos, this.points[i].y + this.yPos)
                    ) {
                        return true;
                    }
                }

                return false;
            }

            detectCollision(item) {
                for (let i = 0; i < this.centers.length; ++i) {
                    if (this.inCollision(item, this.centers[i].x, this.centers[i].y)) {
                        return true;
                    }
                }
                return false;
            }

            /**
             * Detect collision.
             * Return 0 for no collision
             * Return 1 for collision
             * Retrun 2 for collision but the new asteroid is unstable.
             */
            detectBulletCollision(bullet) {
                if (bullet.dead) {
                    return 0;
                }
                if (this.detectCollision(bullet)) {
                    bullet.dead = true;
                    const number = this.factors.find(x => x === bullet.number);
                    if (number) {
                        this.product = this.product / number;
                        if (this.product === 1) {
                            this.dead = true;
                            return 1;
                        } else {
                            const vector = this.vector + (180 + (Math.random() * 20 * coinToss()));
                            const magnitude = this.magnitude * ((Math.random() * 5) + 1)
                            const f = new Factoroid(number, new Point(this.xPos, this.yPos), this.upperBounds, vector, magnitude);
                            if (fb[fbIndex].name === 'Splinter') {
                                this.hasSpawn = true;
                                this.spawn.push(this);
                                this.spawn.push(f);
                            }
                        }
                    } else {
                        this.product = this.product * bullet.number;
                    }
                    if (this.product > this.maxSize) {
                        this.hasSpawn = true;
                        this.spawn = this.stabilize();
                        return 2;
                    }
                    this.generateFactors();
                    this.generatePoints();

                    return 1;
                }
                return 0;
            }

            detectShipCollision(ship) {
                if (ship.collisionShieldCountdown <= 0 && !ship.dead && this.detectCollision(ship)) {
                    ship.death();
                }
            }

            onRight() {
                return this.xPos + this.maxRadius > this.upperBounds.x
            }

            onLeft() {
                return this.xPos - this.maxRadius < 0;
            }

            onBottom() {
                return this.yPos + this.maxRadius > this.upperBounds.y;
            }

            onTop() {
                return this.yPos - this.maxRadius < 0;
            }

            generateCenters() {
                this.centers = [new Point(this.xPos, this.yPos)];
                if (this.onRight()) {
                    this.centers.push(new Point(
                        this.xPos - this.upperBounds.x,
                        this.yPos));
                    if (this.onTop()) {
                        this.centers.push(new Point(
                            this.xPos - this.upperBounds.x,
                            this.yPos + this.upperBounds.y));
                    }
                    if (this.onBottom()) {
                        this.centers.push(new Point(
                            this.xPos - this.upperBounds.x,
                            this.yPos - this.upperBounds.y));
                    }

                }
                if (this.onLeft()) {
                    this.centers.push(new Point(
                        this.xPos + this.upperBounds.x,
                        this.yPos));
                    if (this.onTop()) {
                        this.centers.push(new Point(
                            this.xPos + this.upperBounds.x,
                            this.yPos + this.upperBounds.y));
                    }
                    if (this.onBottom()) {
                        this.centers.push(new Point(
                            this.xPos + this.upperBounds.x,
                            this.yPos - this.upperBounds.y));
                    }
                }
                if (this.onBottom()) {
                    this.centers.push(new Point(
                        this.xPos,
                        this.yPos - this.upperBounds.y));
                }
                if (this.onTop()) {
                    this.centers.push(new Point(
                        this.xPos,
                        this.yPos + this.upperBounds.y));
                }

                return this.centers;
            }



            privateDraw(context, xLoc, yLoc) {
                context.save();
                context.beginPath();
                context.lineWidth = 3;
                context.strokeStyle = this.color;
                context.moveTo(this.points[0].x + xLoc, this.points[0].y + yLoc);
                for (i = 1; i < this.points.length; ++i) {
                    context.lineTo(this.points[i].x + xLoc, this.points[i].y + yLoc);
                }

                context.lineTo(this.points[0].x + xLoc, this.points[0].y + yLoc);
                context.closePath();

                context.stroke();

                context.restore();

                context.fillStyle = 'white';
                context.font = '14pt Courier';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(this.product, xLoc, yLoc);
            }


            privateDrawRadii(context, xLoc, yLoc) {
                context.save();

                for (i = 0; i < this.points.length; ++i) {
                    context.beginPath();
                    context.lineWidth = 0.75
                    context.strokeStyle = 'orange';
                    context.moveTo(xLoc, yLoc);
                    context.lineTo(this.points[i].x + xLoc, this.points[i].y + yLoc);

                    context.stroke();
                }
                context.restore();
            }

            drawRadii(context) {
                this.centers.forEach(p => {
                    this.privateDrawRadii(context, p.x, p.y);
                });

            }

            draw(context) {

                this.centers.forEach(p => {
                    this.privateDraw(context, p.x, p.y);
                });
            }
        }

        class Bullet extends BaseSprite {
            constructor(number, origin, xVel, yVel, upperBounds, ttl) {
                super(origin, upperBounds);
                this.path = [new Point(this.xPos, this.yPos)];
                this.xVelocity = xVel;
                this.yVelocity = yVel;
                this.ttl = ttl;
                this.number = number;
                this.rotation = 0;
                this.rVelocity = 45;
                this.radius = (Math.floor(Math.log10(number * 10 + 1)) * 9) / 2;
                this.dead = false;
            }

            expired() {
                return this.ttl < 0 || this.dead;
            }

            getRotatedRadius() {
                const thetaR = degreesToRadians(this.rotation);
                const x1 = this.xPos - (this.radius * Math.cos(thetaR));
                const x2 = this.xPos + (this.radius * Math.cos(thetaR));
                const y1 = this.yPos - (this.radius * Math.sin(thetaR));
                const y2 = this.yPos + (this.radius * Math.sin(thetaR));

                return { x1, y1, x2, y2 };
            }


            update(time) {
                this.xPos += this.xVelocity;
                this.yPos += this.yVelocity;
                this.rotation += this.rVelocity;
                this.path.push(new Point(this.xPos, this.yPos));

                if (this.xPos < 0) {
                    this.xPos = this.upperBounds.x + this.xPos;
                }
                if (this.yPos < 0) {
                    this.yPos = this.upperBounds.y + this.yPos;
                }
                if (this.xPos > this.upperBounds.x) {
                    this.xPos = this.xPos - this.upperBounds.x;
                }
                if (this.yPos > this.upperBounds.y) {
                    this.yPos = this.yPos - this.upperBounds.y;
                }

                this.ttl -= 1;
            }

            drawPath(context) {
                this.path.forEach(p => {
                    context.beginPath();
                    context.fillStyle = 'white';
                    context.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                    context.fill()
                });
            }

            draw(context) {
                context.save();
                context.translate(this.xPos, this.yPos);
                context.rotate(degreesToRadians(this.rotation));
                context.fillStyle = 'yellow';
                context.font = '12pt Courier';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(this.number, 0, 0);
                context.restore();
            }
        };


        function fireBullet(ship, b) {
            bullets.push(new Bullet(b,
                new Point(ship.xPos, ship.yPos),
                ship.xVelocity - Math.cos(degreesToRadians(ship.rotation + 90)) * 20,
                ship.yVelocity - Math.sin(degreesToRadians(ship.rotation + 90)) * 20,
                ship.upperBounds,
                120
            ));
        }


        function generateFiringSolutions(ship) {
            const fs1 = {
                fire: () => {
                    if (ship.keyHandler.fire() && ship.breachNumber > 0) {
                        if (bullets.length === 0) {
                            const b = ship.keyHandler.number();
                            fireBullet(ship, b);
                            ship.breachNumber = 0;
                            ship.keyHandler.clearNumber();
                        }
                    }
                },
                name: 'Default'
            }

            const fs2 = {
                fire: () => {
                    const b = ship.keyHandler.number();
                    if (b > 0 && bullets.length === 0) {
                        fireBullet(ship, b);
                    }
                    ship.breachNumber = 0;
                    ship.keyHandler.clearNumber();
                },
                name: 'Rapid'
            }

            const fs3 = {
                fire: () => {
                    if (ship.keyHandler.fire() && ship.breachNumber > 0) {
                        if (bullets.length === 0) {
                            const b = ship.keyHandler.number();
                            fireBullet(ship, b);
                            ship.breachNumber = 0;
                            ship.keyHandler.fired();
                        }
                    }
                },
                name: 'Sticky'
            }

            return [fs1, fs2, fs3];
        }

        // Objects
        class Ship extends BaseSprite {
            constructor(origin, upperBounds, keyHandler, number, stepSize, maxSize, outline = 'yellow', drawRadii = false) {
                super(origin, upperBounds);
                this.origin = origin;
                this.breachNumber = 0;
                this.keyHandler = keyHandler;
                this.count = 0;
                this.radius = 12;
                this.number = number;
                this.factors = new Array();
                this.points = new Array();
                this.innerPoints = new Array();
                this.radii = new Array();
                this.maxRadius = 0;
                this.minRadius = 100000;
                this.origin = origin;
                this.stepSize = stepSize % 180;
                this.maxSize = maxSize / 2;
                this.outline = outline;
                this.drawR = drawRadii
                this.firingSolutionIndex = 0;
                this.firingSolutions = generateFiringSolutions(this);
                this.firingSolutionCooldown = 0;

                this.generateFactors();
                this.generatePoints();
                this.reset();
            }

            generateFactors() {
                // GetFactors
                var t = this.number
                var index = 0
                var sqt = Math.sqrt(t)
                while (t != 1) {
                    var factor = primes[index]
                    if ((t % factor) === 0) {
                        this.factors.push(factor);
                        t = t / factor;
                        sqt = Math.sqrt(t)
                    }
                    else {
                        index += 1;
                        factor = primes[index];
                        if (factor > sqt) {
                            this.factors.push(t);
                            return;
                        }
                    }
                }
            }


            sumTheFactors(theta) {
                let sum = 0;

                for (var i = 0; i < this.factors.length; i++) {
                    const f = this.factors[i];
                    sum += Math.cos(f * theta);
                }

                if (sum < 0) {
                    sum = -sum;
                }
                return sum;
            }

            generatePoints() {
                var innerDelta = Math.max(this.number, 4);
                let i;
                for (i = 0; i < 360; i += this.stepSize) {
                    var theta = degreesToRadians(Number(i));
                    var sum = this.sumTheFactors(theta);
                    var radius = (Math.log(this.number) * (5 + sum)) + 7;
                    this.radii.push(radius);
                    this.maxRadius = Math.max(this.maxRadius, radius);
                    this.minRadius = Math.min(this.minRadius, radius);
                }

                // scale it down to our max size
                if (this.maxRadius > this.maxSize) {
                    // maxRadius * x = maxSize;
                    // x = maxSize / maxRadius;
                    const ratio = this.maxSize / this.maxRadius;
                    this.radii = this.radii.map(r => r * ratio);
                }

                i = 0;
                this.radii.forEach(r => {
                    var theta = degreesToRadians(Number(i));
                    var x = (r * Math.cos(theta));
                    var y = -(r * Math.sin(theta));
                    var innerX = ((r - innerDelta) * Math.cos(theta));
                    var innerY = -((r - innerDelta) * Math.sin(theta));
                    this.points.push(new Point(x, y));
                    this.innerPoints.push(new Point(innerX, innerY));
                    i += this.stepSize;
                });
            }

            setUpperBounds(ub) {
                super.setUpperBounds(ub);
                this.origin.x = ub.x / 2;
                this.origin.y = ub.y / 2;
            }

            getRotatedRadius() {
                const thetaR = degreesToRadians(this.rotation - 90);
                const x1 = this.xPos - (this.radius * Math.cos(thetaR));
                const x2 = this.xPos + (this.radius * Math.cos(thetaR));
                const y1 = this.yPos - (this.radius * Math.sin(thetaR));
                const y2 = this.yPos + (this.radius * Math.sin(thetaR));

                return { x1, y1, x2, y2 };
            }

            death() {
                this.dead = true;
            }

            reset() {
                this.xPos = this.origin.x;
                this.yPos = this.origin.y;
                this.xVelocity = 0;
                this.yVelocity = 0;
                this.rotation = 0;
                this.dead = false;
                this.deathCountDown = 5;
                this.particleCloudExtent = 2;
                this.collisionShieldCountdown = 4;
                this.breachNumber = 0;
                this.keyHandler.clearNumber();
            }

            addSpecial(special) {
                this.special = new special();
            }

            updatePosition() {
                this.xPos += this.xVelocity;
                this.yPos += this.yVelocity;

                if (this.xPos < 0) {
                    this.xPos = this.upperBounds.x + this.xPos;
                }
                if (this.yPos < 0) {
                    this.yPos = this.upperBounds.y + this.yPos;
                }
                if (this.xPos > this.upperBounds.x) {
                    this.xPos = this.xPos - this.upperBounds.x;
                }
                if (this.yPos > this.upperBounds.y) {
                    this.yPos = this.yPos - this.upperBounds.y;
                }
            }

            update(delta) {
                if (this.dead && this.deathCountDown > 0) {
                    this.deathCountDown -= delta;
                    this.particleCloudExtent *= 1.02;
                    this.updatePosition();
                    if (this.deathCountDown < 0) {
                        this.reset();
                    }
                    return;
                }
                if (this.collisionShieldCountdown > 0) {
                    this.collisionShieldCountdown -= delta;
                }
                if (this.keyHandler.left()) {
                    this.rotation -= 2;
                }
                if (this.keyHandler.right()) {
                    this.rotation += 2;
                }
                if (this.keyHandler.accelerate()) {

                    this.xVelocity -= Math.cos(degreesToRadians(this.rotation + 90)) / 25;
                    this.yVelocity -= Math.sin(degreesToRadians(this.rotation + 90)) / 25;
                }
                else {
                    this.xVelocity = this.xVelocity / 1.01;
                    this.yVelocity = this.yVelocity / 1.01;
                }

                if (this.special) {
                    this.special.tick();
                    if (this.keyHandler.special()) {
                        this.special.update(this, facts, delta);
                    }
                }

                this.updatePosition();

                if (this.keyHandler.reset()) {
                    this.reset();
                }
                this.updateBreach(delta);
            }

            fire() {
                this.firingSolutions[this.firingSolutionIndex].fire();
            }

            updateBreach(time) {
                this.breachNumber = this.keyHandler.number();
                if (this.keyHandler.firingSolution() && this.firingSolutionCooldown === 0) {
                    this.firingSolutionIndex = (this.firingSolutionIndex + 1) % this.firingSolutions.length;
                    this.firingSolutionCooldown = 12;
                }
                if (this.firingSolutionCooldown > 0) {
                    this.firingSolutionCooldown -= 1;
                }
                this.fire();
            }

            drawRadii(context, xLoc, yLoc) {
                context.save();

                for (i = 0; i < this.points.length; ++i) {
                    context.beginPath();
                    context.lineWidth = 0.75
                    context.strokeStyle = 'black';
                    context.moveTo(xLoc, yLoc);
                    context.lineTo(this.points[i].x + xLoc, this.points[i].y + yLoc);

                    context.stroke();
                }
                context.restore();
            }

            draw(context) {
                if (!this.dead) {
                    context.save();
                    context.translate(this.xPos, this.yPos);
                    context.rotate(degreesToRadians(this.rotation - 90));
                    context.beginPath();
                    context.moveTo(this.points[0].x, this.points[0].y);
                    for (i = 1; i < this.points.length; ++i) {
                        context.lineTo(this.points[i].x, this.points[i].y);
                    }

                    context.lineTo(this.points[0].x, this.points[0].y);
                    context.closePath();

                    context.fillStyle = this.collisionShieldCountdown > 0 ? 'orange' : 'yellow';
                    context.fill();
                    context.lineWidth = 0.5;
                    context.strokeStyle = this.outline;
                    context.stroke();
                    context.restore();

                    context.save();
                    context.translate(this.xPos, this.yPos);
                    context.rotate(degreesToRadians(this.rotation));
                    if (this.breachNumber > 0) {
                        context.fillStyle = 'yellow';
                        context.font = '12pt Courier';
                        context.textAlign = 'center';
                        context.textBaseline = 'middle';
                        context.fillText(this.breachNumber, 0, -31);
                    }
                    context.restore();
                    if (this.drawR) {
                        this.drawRadii(context, this.xPos, this.yPos)
                    }
                    // const rr = this.getRotatedRadius();
                    // context.beginPath();
                    // context.moveTo(rr.x1, rr.y1);
                    // context.strokeStyle = 'red'
                    // context.lineTo(rr.x2, rr.y2);
                    // context.stroke();
                    // context.beginPath();
                    //     context.arc(rr.x1, rr.y1, 2, 0, 2 * Math.PI);
                    //     context.fillStyle = 'red';
                    //     context.fill();
                    //     context.closePath();
                    //     context.beginPath();
                    //     context.arc(rr.x2, rr.y2, 2, 0, 2 * Math.PI);
                    //     context.fillStyle = 'purple';
                    //     context.fill();
                    //     context.closePath();
                } else {
                    const points = [];
                    for (let i = 0; i < 10; ++i) {
                        const range = this.radius + this.particleCloudExtent;
                        const angle = Math.random() * 2 * Math.PI;
                        const x = (Math.random() * range) * Math.cos(angle);
                        const y = (Math.random() * range) * Math.sin(angle);
                        const size = Math.random() * 2;
                        context.beginPath();
                        context.arc(x + this.xPos, y + this.yPos, size, 0, 2 * Math.PI);
                        context.fillStyle = 'yellow';
                        context.fill();
                        context.closePath();
                    }
                }
            }
        }


        // functions

        function getProductFromLevelSimpleMax(level) {
            const index = primes.findIndex(p => p === level);
            const max = (primes[index] * primes[index]) + 1;
            const product = Math.max(2, Math.floor(Math.random() * max));
            return product;
        }

        function getProductFromLevelSimpleMaxV2(level) {
            const index = primes.findIndex(p => p === level);
            const max = (primes[index] * 4) + 1;
            const product = Math.max(2, Math.floor(Math.random() * max));
            return product;
        }

        function getProductFromLevelRandomFactors(level) {
            var product = 1;
            var index = 0;
            while (primes[index] <= level) {
                index += 1;
            }

            factorCount = Math.floor(Math.random() * index) + 1;
            for (var i = 0; i < factorCount; ++i) {
                product *= primes[Math.floor(Math.random() * (index + 1))];
            }
        }

        function getProductFromLevelBuildup(level) {

            const index = primes.findIndex(p => p === level) + 1;
            const max = (primes[index] * primes[index]) + 1;
            const factorCount = Math.floor(Math.random() * index) + 1;

            let i = 0;
            let product = 1;

            for (let x = 0; x < factorCount; ++x) {
                product = product * primes[i];
                i = i + (coinToss() === 1 ? 1 : 0);
                i = Math.min(i, index);
            }

            return product;
        }

        let level = getQueryVariable('level', 2);
        const drawRadii = getQueryVariable('drawRadii', false);
        let down = false;
        function mouseDown(evt) {
            down = true;
            mouseMove(evt);
        }

        function mouseUp() {
            down = false;
        }

        function mouseMove(evt) {
            if (down && level === 'debug') {
                var origin = new Point(canvas.width / 2, canvas.height / 2);
                var point = new Point(evt.clientX, evt.clientY);
                const f = facts[0];
                if (f) {
                    f.xPos = point.x;
                    f.yPos = point.y;
                    f.xVelocity = 0;
                    f.yVelocity = 0;
                }
            }
        }

        // goo
        window.requestAnimFrame = (function (callback) {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
        })();


        var canvas = document.getElementById('AstCan');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas()

        function populateLevel() {
            if (level === 'debug') {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                // facts.push(new Factoroid(2 * 3 * 5 * 7 * 11, new Point(x, y), new Point(canvas.width, canvas.height)));
                facts.push(new Factoroid(1172490, new Point(x, y), new Point(canvas.width, canvas.height)));
            } else {
                for (var i = 0; i < level; ++i) {
                    qNumber = getProductFromLevelSimpleMax(level);
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    facts.push(new Factoroid(qNumber, new Point(x, y), new Point(canvas.width, canvas.height)));
                }
            }
        }

        if (level !== 'debug') {
            level = parseInt(level);
        }

        populateLevel();

        const keyHandler = new KeyHandler();
        let xtraCooldown = 0;
        let xtraIndex = 0;
        const xtras = [FlipSpecial, HyperSpecial];

        const bluntness = coinToss() > 0 ? 100000 : 1000;
        const number = primes[Math.floor(Math.random() * 1000)] * bluntness;
        const stepSize = steps[Math.floor(Math.random() * steps.length)];
        const ship = new Ship(new Point(canvas.width / 2, canvas.height / 2), new Point(canvas.width, canvas.height), keyHandler, number, stepSize, 50);
        ship.addSpecial(FlipSpecial);

        window.addEventListener('resize', resizeCanvas, false);

        function paintLevel(context, level) {
            context.fillStyle = 'white';
            context.font = '16pt Courier';
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.fillText(`Level: ${level}`, 5, 10);
        }

        function paintFiringSolution(context, ship) {
            context.fillStyle = 'white';
            context.font = '12pt Courier';
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.fillText(`FS: ${ship.firingSolutions[ship.firingSolutionIndex].name}`, 5, 30);
        }

        function paintFactoroidBehavoir(context) {
            context.fillStyle = 'white';
            context.font = '12pt Courier';
            context.textAlign = 'left';
            context.textBaseline = 'middle';
            context.fillText(`FB: ${fb[fbIndex].name}`, 5, 47);
        }

        function animate(now) {
            var newNow = new Date().getTime();
            var time = (newNow - now) / 1000.0;
            var context = canvas.getContext('2d');

            context.clearRect(0, 0, canvas.width, canvas.height);

            if (facts.length === 0) {
                if (level !== 'debug') {
                    const index = primes.findIndex(l => l === level) + 1;
                    level = primes[index];
                }
                populateLevel();
                ship.reset();
            }

            bullets.forEach(b => {
                facts.forEach(f => f.detectBulletCollision(b))
            });

            facts.forEach(f => f.detectShipCollision(ship));

            const spawner = facts.filter(f => f.hasSpawn)[0]; // should only be one;
            facts = facts.filter(f => !f.dead && !f.hasSpawn);
            if (spawner) {
                const newFactoroids = spawner.spawn.map(x => {
                    x.hasSpawn = false; // no recursive spawning;
                    x.spawn = []; // clean up the spawn array; 
                    return x;
                });
                facts = facts.concat(newFactoroids);
            }



            for (var i = 0; i < facts.length; ++i) {
                facts[i].setUpperBounds(new Point(canvas.width, canvas.height));
                facts[i].update(time);
                facts[i].draw(context);
                if (drawRadii) {
                    facts[i].drawRadii(context);
                }
            }

            ship.setUpperBounds(new Point(canvas.width, canvas.height));
            ship.update(time);
            ship.draw(context);
            if (bullets.length > 0) {
                bullet = bullets[0];
                bullet.setUpperBounds(new Point(canvas.width, canvas.height));
                bullet.update(time);
                bullet.draw(context);
                if (level === 'debug') {
                    bullet.drawPath(context);
                }
                if (bullet.expired()) {
                    bullets.pop();
                }
            }

            if (keyHandler.factoroidBehavior() && fbCooldown === 0) {
                fbIndex = (fbIndex + 1) % fb.length;
                fbCooldown = 12;
            }

            if (fbCooldown > 0) {
                fbCooldown -= 1;
            }

            paintLevel(context, level);
            paintFiringSolution(context, ship);
            paintFactoroidBehavoir(context);


            if (keyHandler.xtra() && xtraCooldown === 0) {
                xtraIndex = (xtraIndex + 1) % xtras.length;
                ship.addSpecial(xtras[xtraIndex]);
                xtraCooldown = 20;
            }
            if (xtraCooldown > 0) {
                xtraCooldown -= 1;
            }

            requestAnimFrame(function () {
                animate(newNow);
            });
        }
        var now = new Date().getTime();
        animate(now);
        document.onmousedown = mouseDown;
        document.onmouseup = mouseUp;
        document.onmousemove = mouseMove;
    </script>
</body>

</html>